From effa4a25f3f769667d2a2c4d7d36564e9ff7618b Mon Sep 17 00:00:00 2001
From: Serge Hallyn <serge.hallyn@ubuntu.com>
Date: Sun, 2 Nov 2014 14:01:18 +0000
Subject: cgmanager: fix 'attach' with "all" controller support
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

"all" is not a supported keyword for cgmanager's get_pid_cgroup.
Pass the first mounted cgroup subsystem instead of passing "all" when
getting the container's cgorup to attach to.

Also, make sure that the target cgroup is in fact in all identical
cgroups before attaching with 'all".  If not, then we must attach to
each cgroup separately, or else we will not be in all the same cgroups
as the target container.

Signed-off-by: Serge Hallyn <serge.hallyn@ubuntu.com>
Acked-by: St√©phane Graber <stgraber@ubuntu.com>
---
 src/lxc/cgmanager.c | 28 +++++++++++++++++++++++-----
 1 file changed, 23 insertions(+), 5 deletions(-)

diff --git a/src/lxc/cgmanager.c b/src/lxc/cgmanager.c
index 0aad9e5..68ce2ce 100644
--- a/src/lxc/cgmanager.c
+++ b/src/lxc/cgmanager.c
@@ -189,11 +189,22 @@ static bool cgm_supports_multiple_controllers;
  */
 static bool cgm_all_controllers_same;
 
-static void check_supports_multiple_controllers(void)
+/*
+ * Check whether we can use "all" when talking to cgmanager.
+ * We check two things:
+ * 1. whether cgmanager is new enough to support this.
+ * 2. whether the task we are interested in is in the same
+ *    cgroup for all controllers.
+ * In cgm_init (before an lxc-start) we care about our own
+ * cgroup.  In cgm_attach, we care about the target task's
+ * cgroup.
+ */
+static void check_supports_multiple_controllers(pid_t pid)
 {
 	FILE *f;
 	char *line = NULL, *prevpath = NULL;
 	size_t sz = 0;
+	char path[100];
 
 	cgm_supports_multiple_controllers = false;
 	cgm_all_controllers_same = false;
@@ -205,7 +216,11 @@ static void check_supports_multiple_controllers(void)
 
 	cgm_supports_multiple_controllers = true;
 
-	f = fopen("/proc/self/cgroup", "r");
+	if (pid == -1)
+		sprintf(path, "/proc/self/cgroup");
+	else
+		sprintf(path, "/proc/%d/cgroup", pid);
+	f = fopen(path, "r");
 	if (!f)
 		return;
 
@@ -517,7 +532,7 @@ static void *cgm_init(const char *name)
 		return NULL;
 	}
 
-	check_supports_multiple_controllers();
+	check_supports_multiple_controllers(-1);
 
 	d = malloc(sizeof(*d));
 	if (!d) {
@@ -1280,13 +1295,16 @@ static bool cgm_attach(const char *name, const char *lxcpath, pid_t pid)
 		return false;
 	}
 
-	check_supports_multiple_controllers();
+	check_supports_multiple_controllers(pid);
 
 	if (cgm_all_controllers_same)
 		slist = subsystems_inone;
 
 	for (i = 0; slist[i]; i++) {
-		cgroup = try_get_abs_cgroup(name, lxcpath, slist[i]);
+		if (slist == subsystems_inone)
+			cgroup = try_get_abs_cgroup(name, lxcpath, subsystems[0]);
+		else
+			cgroup = try_get_abs_cgroup(name, lxcpath, slist[i]);
 		if (!cgroup) {
 			ERROR("Failed to get cgroup for controller %s", slist[i]);
 			cgm_dbus_disconnect();
